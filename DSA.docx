PATTERNS

1.  ****
    ****
    ****
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
2.  *
    **
    ***
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i <= n; i++){
        for(let j = 0; j < i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
3.  1
    12
    123
    1234
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
4.  1
    22
    333
    4444
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += i+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
5.  ****
    ***
    **
    *
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
6.  1234
    123
    12
    1
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
7.    *  
     *** 
    *****
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < 3; i++) {
        for (let j = 1; j <= 3 * 2 - 1; j++) {
            if (j < 3 - i || j > 3 + i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
8.  ***** 
     *** 
      *
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n * 2 - 1; j++) {
            if (j < i || j >= n * 2 - 1 - i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
BASIC MATHS

9. Count the digits
const countDigits = (num) => {
    let count = 0;
    while(num > 0){
        count++;
        num = Math.floor(num/10)
    }
    return count
}
console.log(countDigits(24234))
TC: O(logn); SC: O(1)
const countDigitsLog = (num) => {
    return Math.floor(Math.log10(num))+1
}
console.log(countDigitsLog(24234))
TC: O(1); SC: O(1)

-------------------------------------------------------------------------
10.0 Reverse number
var reverse = function (x) {
  let num = 0,
    sign = x > 0 ? 1 : -1;
  x = Math.abs(x);
  while (x > 0) {
    let lastDigit = x % 10;
    x = Math.floor(x / 10);
    num = num * 10 + lastDigit;
  }
  if (num > Math.pow(2, 31) - 1) {
    return 0;
  }
  return num * sign;
};
TC: O(logn); SC: O(1)
10.1 Pallindrome number
var isPalindrome = function(x) {
    if(x<0) return false
    let num = x, reverseNum = 0
    while(num>0){
        let lastDigit = num % 10;
        num = Math.floor(num/10)
        reverseNum = (reverseNum*10) + lastDigit
    }
    return reverseNum === x
};
TC: O(logn); SC: O(1)

-------------------------------------------------------------------------
11. Armstrong number
const checkArmstrong = (num) => {
  let dup = num;
  let digits = Math.floor(Math.log10(num)) + 1;
  let sum = 0;
  while (dup > 0) {
    let lastDigit = dup % 10;
    dup = Math.floor(dup / 10);
    sum += Math.pow(lastDigit, digits);
  }
  return sum === num;
};
TC: O(logn); SC: O(1)

-------------------------------------------------------------------------
12. Print Divisors
const printDivisors = (num) => {
    for(let i = 1; i <= num; i++){
        if(num % i === 0) console.log(i)
    }
}
TC: O(n); SC: O(1)
printDivisors(36)
const printDivisorsSqrt = (num) => {
  // if sorted ans is not required we can skip array & can directly use console.log
  let small = [],
    large = [];
  // for(let i = 1; i <= Math.sqrt(num); i++){
  for (let i = 1; i * i <= num; i++) {
    if (num % i === 0) {
      small.push(i);
      if (num / i !== i) large.push(num / i);
    }
  }
  for (a of small) console.log(a);
  for (let b = large.length - 1; b > 0; b--) console.log(large[b]);
};
printDivisorsSqrt(36);
TC: O(√n); SC: O(√n)

-------------------------------------------------------------------------
13. Prime number
const isPrime = (n) => {
  if (n <= 1) return false;
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) return false;
  }
  return true;
};
TC: O(√n); SC: O(1)

-------------------------------------------------------------------------
14. GCD/HCF => using Euclidean Algorithm
const hcf = (a, b) => {
  while (a > 0 && b > 0) {
    if (a > b) a = a % b;
    if (b > a) b = b % a;
  }
  if (a === 0) return b;
  return a;
};
console.log(hcf(20, 40));
TC: O(log min(a, b)); SC: O(1)
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
TC: O(log min(a, b)); SC: O(log min(a, b))
const gcdBest = (a, b) => {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b !== 0) {
    let temp = b;
    b = a % b;
    a = temp;
  }
  return a;
};
TC: O(log min(a, b)); SC: O(1)

-------------------------------------------------------------------------
RECURSION

15. Print name 5 times
let count = 0;
const printName = () => {
  if (count === 5) return;
  console.log("Reema");
  count++;
  printName();
};
printName();

-------------------------------------------------------------------------
16. Print from 1 to N by backtracking (calling fun first & then printing value later)
const printNumber = (i, n) => {
  if (i < 1) return;
  printNumber(i - 1, n);
  console.log(i);
};
printNumber(3, 3);

-------------------------------------------------------------------------
17. Print from N to 1
const printNum = (i, n) => {
  if (n < 1) return;
  console.log(n);
  printNum(i, n - 1);
};
printNum(3, 3);

-------------------------------------------------------------------------
18. Sum of 1st n numbers
const sumOf = (n) => {
  if (n === 0) return 0;
  return n + sumOf(n - 1);
};
console.log(sumOf(3));

-------------------------------------------------------------------------
19. Factorial of N
const factOf = (n) => {
  if (n === 0) return 1;
  return n * factOf(n - 1);
};
console.log(factOf(3));

-------------------------------------------------------------------------
20. Reverse an array
const reverseArray = (arr, left = 0, right = arr.length - 1) => {
  if (left >= right) return;
  [arr[left], arr[right]] = [arr[right], arr[left]];
  reverseArray(arr, left + 1, right - 1);
};
let arr = [1, 2, 3, 4, 5];
reverseArray(arr);
console.log(arr);

-------------------------------------------------------------------------
21. A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
var isPalindrome = function (s) {
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (left < right && !isAlphanumeric(s[left])) {
      left++;
    }
    while (left < right && !isAlphanumeric(s[right])) {
      right--;
    }
    if (s[left].toLowerCase() !== s[right].toLowerCase()) {
      return false;
    }
    left++;
    right--;
  }
  return true;
};
const isAlphanumeric = (char) => {
  return (
    (char >= "a" && char <= "z") ||
    (char >= "A" && char <= "Z") ||
    (char >= "0" && char <= "9")
  );
};

-------------------------------------------------------------------------
22. Fibonacci number
const fib = (n, memo = {}) => {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
};
console.log(fib(4));

-------------------------------------------------------------------------
SORTING

1. Selection sort
const selectionSort = (arr) => {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    // Assume the first unsorted element is the minimum
    let minIndex = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j; // Update index if a smaller element is found
      }
    }
    // Swap the found minimum element with the first unsorted element
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  return arr;
};
const data2 = [29, 10, 14, 37, 13];
console.log("Selection Sort:", selectionSort(data2));
TC: O(n2) (Avg, Best & Worst case); SC: O(1)

-------------------------------------------------------------------------
2. Bubble Sort
const bubbleSort = (arr) => {
  let n = arr.length;
  let swapped;
  for (let i = 0; i < n - 1; i++) {
    swapped = false;
    // Inner loop: elements at the end are already sorted
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // Swap elements
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    // If no two elements were swapped by inner loop, then break
    if (!swapped) break;
  }
  return arr;
};
const data = [64, 34, 25, 12, 22, 11, 90];
console.log("Bubble Sort:", bubbleSort(data));
Tc: O(n2) - Worst & Average; O(n) - Best case

-------------------------------------------------------------------------
3. Insertion sort
const insertionSort = (arr) => {
  for (let i = 1; i < arr.length; i++) {
    let j = i - 1;
    let key = arr[i];
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
};
const data = [64, 34, 25, 12, 22, 11, 90];
console.log("Insertion Sort:", insertionSort(data));

-------------------------------------------------------------------------
4. Merge Sort
const merge = (arr, low, mid, high) => {
  let temp = [], left = low, right = mid+1
  while(left<=mid&& right<=high){
    if(arr[left]<=arr[right]){
      temp.push(arr[left])
      left++
    }else{
      temp.push(arr[right])
      right++
    }
  }
  while(left<=mid){
    temp.push(arr[left])
    left++
  }
  while(right<=high){
    temp.push(arr[right])
    right++
  }
  for(let i =low; i<high;i++){
    arr[i] = temp[i - low]
  }
}
const mergeSort = (arr, low = 0, high = arr.length-1) => {
  if(low>=high) return
  let mid = Math.floor((low+high)/2)
  mergeSort(arr, low, mid)
  mergeSort(arr, mid+1, high)
  merge(arr, low, mid, high)
}
let arr = [3,2,8,5,1,4,23]
mergeSort(arr)
console.log(arr)

-------------------------------------------------------------------------
5. Quick Sort

-------------------------------------------------------------------------
ARRAY EASY

23. Largest element in an array
const findLargest = (arr) => {
  if (arr.length === 0) return null;
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
};
const arr = [3, 7, 2, 9, 4];
console.log(findLargest(arr));

-------------------------------------------------------------------------
24. Find Second Smallest and Second Largest Element in an array
const findSecondSmallestAndLargest = (arr) => {
  if (arr.length < 2) {
    return "Array must have at least two elements";
  }
  let smallest = Infinity,
    secondSmallest = Infinity;
  let largest = -Infinity,
    secondLargest = -Infinity;
  for (let num of arr) {
    // For smallest
    if (num < smallest) {
      secondSmallest = smallest;
      smallest = num;
    } else if (num > smallest && num < secondSmallest) {
      secondSmallest = num;
    }
    // For largest
    if (num > largest) {
      secondLargest = largest;
      largest = num;
    } else if (num < largest && num > secondLargest) {
      secondLargest = num;
    }
  }
  return {
    secondSmallest,
    secondLargest,
  };
};
// Example
const arr = [4, 2, 7, 1, 9, 5];
console.log(findSecondSmallestAndLargest(arr));

-------------------------------------------------------------------------
25. Check if Array Is Sorted and Rotated
const check = (nums) => {
    let drops = 0;
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        if (nums[i] > nums[(i + 1) % n]) {
            drops++;
            if (drops > 1) return false;
        }
    }
    return true;
};
console.log(check([3, 4, 5, 1, 2]))

-------------------------------------------------------------------------
26. Remove Duplicates from Sorted array
const removeDuplicates = (nums) => {
    let i = 0;
    for(let j = 1; j < nums.length; j++){
        if(nums[i] !== nums[j]){
            i++
            nums[i] = nums[j]
        }
    }
    return i+1
};
console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))

-------------------------------------------------------------------------
27. Rotate Array to right by k steps
const rotate = (nums, k) => {
  const n = nums.length;
  k = k % n;
  reverse(nums, 0, n - 1);
  reverse(nums, 0, k - 1);
  reverse(nums, k, n - 1);
  // If i want to rotate to left
  // reverse(nums, 0, k - 1);
  // reverse(nums, k, n - 1);
  // reverse(nums, 0, n - 1);
  return nums;
};
const reverse = (arr, left, right) => {
  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
};
console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));

-------------------------------------------------------------------------
28. Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
const moveZeroes = (nums) => {
  let i = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] !== 0) {
      nums[i] = nums[j];
      i++;
    }
  }
  for (let j = i; j < nums.length; j++) {
    nums[j] = 0;
  }
  return nums;
};
console.log(moveZeroes([0, 1, 3, 0, 0, 12]));

-------------------------------------------------------------------------
29. Given an array of integers nums and an integer target, find the smallest index (0 based indexing) where the target appears in the array. If the target is not found in the array, return -1.
const linearSearchUnSorted = (arr, num) => {
  for (let j = 0; j < arr.length; j++) {
    if (arr[j] === num) return j;
  }
  return -1;
};
console.log(linearSearchUnSorted([3, 2, 5, 7, 8, 4], 5));
const linearSearchSorted = (arr, num) => {
  let left = 0,
    right = arr.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === num) return mid;
    else if (arr[mid] < num) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
};
console.log(linearSearchSorted([1, 2, 5, 7, 8, 10, 12], 5));

-------------------------------------------------------------------------
30. Given two sorted arrays, arr1, and arr2 of size n and m. Find the union of two sorted arrays. The union of two arrays can be defined as the common and distinct elements in the two arrays.
const findUnion = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const unionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
    }
    else if (arr2[j] < arr1[i]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
        unionArr.push(arr2[j]);
      }
      j++;
    }
    else {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  while (i < arr1.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
      unionArr.push(arr1[i]);
    }
    i++;
  }
  while (j < arr2.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
      unionArr.push(arr2[j]);
    }
    j++;
  }
  return unionArr;
};
const arr1 = [1, 1, 2, 3, 4, 5];
const arr2 = [2, 3, 4, 4, 5, 6];
console.log(findUnion(arr1, arr2));
const findIntersection = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const intersectionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      i++;
    } else if (arr2[j] < arr1[i]) {
      j++;
    } else {
      if (
        intersectionArr.length === 0 ||
        intersectionArr[intersectionArr.length - 1] !== arr1[i]
      ) {
        intersectionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  return intersectionArr;
};
const arrA = [1, 2, 2, 3, 5];
const arrB = [2, 3, 3, 5, 7];
console.log(findIntersection(arrA, arrB));

-------------------------------------------------------------------------
31. Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
const missingNumber = (nums) => {
  let n = nums.length;
  let sum = (n * (n + 1)) / 2;
  let arrSum = 0;
  for (let i = 0; i < n; i++) {
    arrSum += nums[i];
  }
  return sum - arrSum;
};
console.log(missingNumber([3, 0, 1]));
const missingNumberXor = (nums) => {
  let xor = nums.length;
  for (let i = 0; i < nums.length; i++) {
    xor ^= i ^ nums[i];
  }
  return xor;
};
console.log(missingNumberXor([3, 0, 1]));

-------------------------------------------------------------------------
32. Given a binary array nums, return the maximum number of consecutive 1's in the array.
const findMaxConsecutiveOnes = (nums) => {
  let i = 0,
    max = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] === 1) {
      i++;
      if (i > max) {
        max = i;
      }
    } else {
      i = 0;
    }
  }
  return max;
};
console.log([1, 1, 0, 0, 1, 1, 1, 0]);

-------------------------------------------------------------------------
33. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
const singleNumber = (nums) => {
  let xor = 0;
  for (let i = 0; i < nums.length; i++) {
    xor ^= nums[i];
  }
  return xor;
};
console.log(singleNumber([4, 1, 2, 1, 2]));

-------------------------------------------------------------------------
34. Given an array nums of size n and an integer k, find the length of the longest sub-array that sums to k. If no such sub-array exists, return 0.
const longestSubArrPositiveNumbersOnly = (arr, k) => {
  let left = 0;
  let sum = 0;
  let maxLen = 0;
  for (let right = 0; right < arr.length; right++) {
    sum += arr[right];
    while (sum > k) {
      sum -= arr[left];
      left++;
    }
    if (sum === k) {
      maxLen = Math.max(maxLen, right - left + 1);
    }
  }
  return maxLen;
};
console.log(longestSubArrPositiveNumbersOnly([10, 5, 2, 7, 1, 9], 15));
const longestSubArrPosNegNumbers = (arr, k) => {
  let map = new Map();
  let sum = 0;
  let maxLen = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    if (sum === k) {
      maxLen = i + 1;
    }
    if (map.has(sum - k)) {
      maxLen = Math.max(maxLen, i - map.get(sum - k));
    }
    if (!map.has(sum)) {
      map.set(sum, i);
    }
  }
  return maxLen;
};
console.log(longestSubArrPosNegNumbers([-1, 1, 1], 1));

-------------------------------------------------------------------------
ARRAY MEDIUM

35. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
const twoSumHash = (nums, target) => {
  let hashMap = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (hashMap.has(nums[i])) return [hashMap.get(nums[i]), i];
    hashMap.set(target - nums[i], i);
  }
};
console.log(twoSumHash([2, 7, 11, 15], 9));
const twoSum = (nums, target) => {
  let obj = {};
  for (let i = 0; i < nums.length; i++) {
    if (obj[nums[i]] !== undefined) return [obj[nums[i]], i];
    obj[target - nums[i]] = i;
  }
};
console.log(twoSum([2, 7, 11, 15], 9));

-------------------------------------------------------------------------
36. Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
const sortColors = (nums) => {
  let low = 0,
    mid = 0,
    high = nums.length - 1;
  while (mid <= high) {
    if (nums[mid] === 0) {
      [nums[mid], nums[low]] = [nums[low], nums[mid]];
      low++;
      mid++;
    } else if (nums[mid] === 1) {
      mid++;
    } else {
      [nums[mid], nums[high]] = [nums[high], nums[mid]];
      high--;
    }
  }
};
console.log(sortColors([2, 0, 2, 1, 1, 0]));

-------------------------------------------------------------------------
37. Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
const majorityElement = (arr) => {
  let majority = Math.ceil(arr.length / 2);
  let obj = {};
  for (let i = 0; i < arr.length; i++) {
    obj[arr[i]] = (obj[arr[i]] || 0) + 1;
  }
  for (let elt in obj) {
    if (obj[elt] >= majority) {
      return +elt;
    }
  }
};
console.log(majorityElement([2,2,1,1,1,2,2]));
// Boyer-Moore's Voting Algo
const majorityElementOp = (arr) => {
  let count = 0;
  let el;
  for (let i = 0; i < arr.length; i++) {
    if (count === 0) {
      el = arr[i];
      count = 1;
    } else if (arr[i] === el) {
      count++;
    } else {
      count--;
    }
  }
  let maxCount = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === el) maxCount++;
  }

  if (maxCount > arr.length / 2) return el;
};
console.log(majorityElementOp([2, 2, 1, 1, 1, 2, 2]));

-------------------------------------------------------------------------
38. Given an integer array nums, find the subarray with the largest sum, and return its sum.
// Kadane’s Algo
const maxSubArray = (nums) => {
  let maxSum = nums[0],
    currSum = 0,
    start = 0,
    startIdx = 0,
    endIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    currSum += nums[i];
    if (currSum > maxSum) {
      maxSum = currSum;
      startIdx = start;
      endIdx = i;
    }
    if (currSum < 0) {
      currSum = 0;
      start = i + 1;
    }
  }
  for (let i = startIdx; i <= endIdx; i++) {
    console.log(nums[i]);
  }
  return maxSum;
};
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));

-------------------------------------------------------------------------
39. You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0
const maxProfit = function (prices) {
  let profit = 0,
    mini = prices[0];
  for (let i = 1; i < prices.length; i++) {
    let max = prices[i] - mini;
    if (max > profit) profit = max;
    if (prices[i] < mini) mini = prices[i];
  }
  return profit;
};
console.log(maxProfit([7, 1, 5, 3, 6, 4]));

-------------------------------------------------------------------------
40. You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers. You should return the array of nums such that the array follows the given conditions: Every consecutive pair of integers have opposite signs; For all integers with the same sign, the order in which they were present in nums is preserved; The rearranged array begins with a positive integer; Return the modified array after rearranging the elements to satisfy the aforementioned conditions;
const rearrangeArray = (nums) => {
  let newArray = new Array(nums.length).fill(0);
  let oddIdx = 1,
    evenIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) {
      newArray[oddIdx] = nums[i];
      oddIdx += 2;
    } else {
      newArray[evenIdx] = nums[i];
      evenIdx += 2;
    }
  }
  return newArray;
};
console.log(rearrangeArray([3, 1, -2, -5, 2, -4]));

-------------------------------------------------------------------------
41. A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
const nextPermutation = (nums) => {
  let breakIdx = -1;
  const reverseArr = (arr, start, end) => {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  };
  for (let i = nums.length - 2; i >= 0; i--) {
    if (nums[i] < nums[i + 1]) {
      breakIdx = i;
      break;
    }
  }
  if (breakIdx === -1) {
    reverseArr(nums, 0, nums.length - 1);
    return nums;
  }
  for (let i = nums.length - 1; i >= breakIdx; i--) {
    if (nums[i] > nums[breakIdx]) {
      [nums[i], nums[breakIdx]] = [nums[breakIdx], nums[i]];
      break;
    }
  }
  reverseArr(nums, breakIdx + 1, nums.length - 1);
  return nums;
};
console.log(nextPermutation([3, 2, 1]));
const nextPermutationOp = (nums) => {
  let i = nums.length - 2;
  const reverseArr = (arr, start, end) => {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  };
  // Step 1: Find the first decreasing element from the right
  while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
  }
  // Step 2: If pivot is found, find the element to swap with
  if (i >= 0) {
    let j = nums.length - 1;
    while (nums[j] <= nums[i]) {
      j--;
    }
    swap(nums, i, j);
  }
  // Step 3: Reverse the suffix to get the next lexicographical smallest
  reverse(nums, i + 1, nums.length - 1);
  return nums;
};

-------------------------------------------------------------------------
42. Leaders in an Array
const leaders = (nums) => {
  let n = nums.length;
  if (n === 0) return [];
  let leadersArr = [nums[n - 1]],
    idx = n - 1;
  for (let i = nums.length - 2; i >= 0; i--) {
    if (nums[i] > nums[idx]) {
      leadersArr.push(nums[i]);
      idx = i;
    }
  }
  // If order need to be maintained then reverse the array if needed
  return leadersArr;
};
console.log(leaders([13, 7, 5, 12, 1]));

-------------------------------------------------------------------------
43. Given an array nums of n integers. Return the length of the longest sequence of consecutive integers. The integers in this sequence can appear in any order.
const longestSequence = (arr) => {
  if (arr.length === 0) return 0;
  const newSet = new Set(arr);
  let longest = 1;
  for (let num of newSet) {
    if (!newSet.has(num - 1)) {
      let currentNum = num;
      let currentStreak = 1;
      while (newSet.has(currentNum + 1)) {
        currentNum += 1;
        currentStreak += 1;
      }
      if (currentStreak > longest) longest = currentStreak;
    }
  }
  return longest;
};
console.log(longestSequence([100, 4, 200, 1, 3, 2]));

-------------------------------------------------------------------------
44. Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.
const setZeroes = (arr) => {
  let m = arr.length;
  let n = arr[0].length;
  let firstColZero = 1;
  for (let i = 0; i < m; i++) {
    if (arr[i][0] === 0) firstColZero = 0;
    for (let j = 1; j < n; j++) {
      if (arr[i][j] === 0) {
        arr[i][0] = 0;
        arr[0][j] = 0;
      }
    }
  }
  for (let i = 1; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (arr[i][0] === 0 || arr[0][j] === 0) {
        arr[i][j] = 0;
      }
    }
  }
  if (arr[0][0] === 0) {
    for (let j = 0; j < n; j++) arr[0][j] = 0;
  }
  if (firstColZero === 0) {
    for (let i = 0; i < m; i++) arr[i][0] = 0;
  }
  return arr;
};
console.log(
  setZeroes([
    [1, 1, 1, 1],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 1],
  ]),
);

-------------------------------------------------------------------------
45. You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
const rotate = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    for (j = i + 1; j < arr.length; j++) {
      [arr[i][j], arr[j][i]] = [arr[j][i], arr[i][j]];
    }
  }
  for (i = 0; i < arr.length; i++) {
    arr[i].reverse();
  }
  return arr;
};
console.log(
  rotate([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
  ]),
);

-------------------------------------------------------------------------
46. Given a Matrix, print the given matrix in spiral order.
const spiralOrder = (matrix) => {
  let top = 0,
    left = 0,
    right = matrix[0].length - 1,
    bottom = matrix.length - 1,
    arr = [];
  while (top <= bottom && left <= right) {
    for (let i = left; i <= right; i++) {
      arr.push(matrix[top][i]);
    }
    top++;
    for (let i = top; i <= bottom; i++) {
      arr.push(matrix[i][right]);
    }
    right--;
    if (top <= bottom) {
      for (let i = right; i >= left; i--) {
        arr.push(matrix[bottom][i]);
      }
      bottom--;
    }
    if (left <= right) {
      for (let i = bottom; i >= top; i--) {
        arr.push(matrix[i][left]);
      }
      left++;
    }
  }
  return arr;
};
console.log(
  spiralOrder([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
  ]),
);

-------------------------------------------------------------------------
47. Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements(positive & negative) within an array.
const subarraySum = (nums, k) => {
  let sum = 0,
    count = 0,
    hashMap = new Map();
  hashMap.set(0, 1);
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (hashMap.has(sum - k)) {
      count += hashMap.get(sum - k);
    }
    hashMap.set(sum, (hashMap.get(sum) || 0) + 1);
  }
  return count;
};
console.log([1, 1, 1], 2);

-------------------------------------------------------------------------
ARRAY HARD

48. Pascal’s Triangle
a. Find value at row = r, column = c (1-indexed)
const pascalValue = (r, c) => {
  if (c < 1 || c > r) return 0;
  let val = 1;
  (r--, c--);
  for (i = 0; i < c; i++) {
    val = (val * (r - i)) / (i + 1);
  }
  return val;
};
console.log(pascalValue(5, 3));
b. Find nth row of Pascal’s Triangle
const getNthRow = (N) => {
  let row = [];
  let val = 1;
  row.push(val);
  for (let i = 1; i < N; i++) {
    val = (val * (N - i)) / i;
    row.push(val);
  }
  return row;
};
console.log(getNthRow(5));
c. Generate Pascal’s Triangle up to N rows
const pascalTriangle = (k) => {
  let triangle = [];
  for (let i = 0; i < k; i++) {
    let subArr = [];
    for (let j = 0; j <= i; j++) {
      if (j === 0 || j === i) {
        subArr.push(1);
      } else {
        subArr.push(triangle[i - 1][j - 1] + triangle[i - 1][j]);
      }
    }
    triangle.push(subArr);
  }
  return triangle;
};
console.log(pascalTriangle(5));

-------------------------------------------------------------------------
49. Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
const majorityElement = (nums) => {
  if (nums.length === 0) return [];
  let cnt1 = 0,
    cnt2 = 0,
    el1,
    el2;
  for (let i = 0; i < nums.length; i++) {
    if (cnt1 === 0 && el2 !== nums[i]) {
      el1 = nums[i];
      cnt1 = 1;
    } else if (cnt2 === 0 && el1 !== nums[i]) {
      el2 = nums[i];
      cnt2 = 1;
    } else if (el1 === nums[i]) {
      cnt1++;
    } else if (el2 === nums[i]) {
      cnt2++;
    } else {
      cnt1--;
      cnt2--;
    }
  }
  let temp1Cnt = 0,
    temp2Cnt = 0;
  for (let i = 0; i < nums.length; i++) {
    if (el1 === nums[i]) temp1Cnt++;
    if (el2 === nums[i]) temp2Cnt++;
  }
  let mini = Math.floor(nums.length / 3);
  let arr = [];
  if (temp1Cnt > mini) arr.push(el1);
  if (temp2Cnt > mini && el2 !== el1) arr.push(el2);
  return arr;
};
console.log(majorityElement([3, 2, 3]));

-------------------------------------------------------------------------
50. Three Sum
const threeSum = (nums, target) => {
  let arr = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i - 1] === nums[i]) continue;
    if (nums[i] + nums[i + 1] + nums[i + 2] > target) break;
    if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] < target)
      continue;
    let j = i + 1,
      k = nums.length - 1;
    while (j < k) {
      let sum = nums[i] + nums[j] + nums[k];
      if (sum === target) {
        arr.push([nums[i], nums[j], nums[k]]);
        j++;
        k--;
        while (j < k && nums[j] === nums[j - 1]) j++;
        while (j < k && nums[k] === nums[k + 1]) k--;
      } else if (sum > 0) {
        k--;
      } else {
        j++;
      }
    }
  }
  return arr;
};
console.log(threeSum([-1, 0, 1, 2, -1, -4], 0));

-------------------------------------------------------------------------
51. Four Sum
const fourSum = (nums, target) => {
  const arr = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length - 3; i++) {
    if (i > 0 && nums[i - 1] === nums[i]) continue;
    if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
    if (
      nums[i] +
        nums[nums.length - 1] +
        nums[nums.length - 2] +
        nums[nums.length - 3] <
      target
    )
      continue;
    for (let j = i + 1; j < nums.length - 2; j++) {
      if (j > i + 1 && nums[j - 1] === nums[j]) continue;
      let k = j + 1,
        l = nums.length - 1;
      while (k < l) {
        let sum = nums[i] + nums[j] + nums[k] + nums[l];
        if (sum === target) {
          arr.push([nums[i], nums[j], nums[k], nums[l]]);
          k++;
          l--;
          while (k < l && nums[k] === nums[k - 1]) k++;
          while (k < l && nums[l] === nums[l + 1]) l--;
        } else if (sum < target) {
          k++;
        } else {
          l--;
        }
      }
    }
  }
  return arr;
};
console.log(fourSum([1, 0, -1, 0, -2, 2], 0));

-------------------------------------------------------------------------
52. Count the number of subarrays with given xor K
const subarrayXor = (nums, target) => {
  let prefixXor = 0;
  let count = 0;
  let map = new Map();
  map.set(0, 1);
  for (let i = 0; i < nums.length; i++) {
    prefixXor ^= nums[i];
    if (map.has(prefixXor ^ target)) {
      count += map.get(prefixXor ^ target);
    }
    map.set(prefixXor, (map.get(prefixXor) || 0) + 1);
  }
  return count;
};
console.log([4, 2, 2, 6, 4], 6);

-------------------------------------------------------------------------
53. Merge Intervals: Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
const merge = (arr) => {
  if (!arr.length) return [];
  arr = arr.sort((a, b) => a[0] - b[0]);
  let intervals = [arr[0]];
  for (let i = 1; i < arr.length; i++) {
    let elt = intervals[intervals.length - 1];
    if (arr[i][0] <= elt[1]) elt[1] = Math.max(arr[i][1], elt[1]);
    else intervals.push(arr[i]);
  }
  return intervals;
};
console.log([
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
]);
