PATTERNS

1.  ****
    ****
    ****
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
2.  *
    **
    ***
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i <= n; i++){
        for(let j = 0; j < i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
3.  1
    12
    123
    1234
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
4.  1
    22
    333
    4444
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += i+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
5.  ****
    ***
    **
    *
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
6.  1234
    123
    12
    1
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
7.    *  
     *** 
    *****
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < 3; i++) {
        for (let j = 1; j <= 3 * 2 - 1; j++) {
            if (j < 3 - i || j > 3 + i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
8.  ***** 
     *** 
      *
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n * 2 - 1; j++) {
            if (j < i || j >= n * 2 - 1 - i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
BASIC MATHS

9. Count the digits
const countDigits = (num) => {
    let count = 0;
    while(num > 0){
        count++;
        num = Math.floor(num/10)
    }
    return count
}
console.log(countDigits(24234))
const countDigitsLog = (num) => {
    return Math.floor(Math.log10(num))+1
}
console.log(countDigitsLog(24234))

-------------------------------------------------------------------------
10. Pallindrome number
var isPalindrome = function(x) {
    if(x<0) return false
    let num = x, reverseNum = 0
    while(num>0){
        let lastDigit = num % 10;
        num = Math.floor(num/10)
        reverseNum = (reverseNum*10) + lastDigit
    }
    return reverseNum === x
};   

-------------------------------------------------------------------------
11. Armstrong number
const checkArmstrong = (num) => {
  let dup = num;
  let digits = Math.floor(Math.log10(num)) + 1;
  let sum = 0;
  while (dup > 0) {
    let lastDigit = dup % 10;
    dup = Math.floor(dup / 10);
    sum += Math.pow(lastDigit, digits);
  }
  return sum === num;
};

-------------------------------------------------------------------------
12. Print Divisors
const printDivisors = (num) => {
    for(let i = 1; i <= num; i++){
        if(num % i === 0) console.log(i)
    }
}
printDivisors(36)
const printDivisorsSqrt = (num) => {
    let small = [], large = []
    // for(let i = 1; i <= Math.sqrt(num); i++){
    for(let i = 1; i*i <= num; i++){
        if(num % i === 0) {
            small.push(i)
            if(num/i !== i) large.push(num/i)
        }
    }
    for(a of small) console.log(a)
    for(let b = large.length-1; b>0; b--) console.log(large[b])
}
printDivisorsSqrt(36)

-------------------------------------------------------------------------
13. Prime number
const isPrime = (n) => {
  if (n <= 1) return false;
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) return false;
  }
  return true;
};

-------------------------------------------------------------------------
14. GCD/HCF => using Euclidean Algorithm
const hcf = (a, b) => {
    while(a>0&&b>0){
        if(a>b) a = a%b
        if(b>a) b = b%a
    }
    if(a===0) return b
    return a
}
console.log(hcf(20, 40))
const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
const gcdBest = (a, b) => {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b !== 0) {
    let temp = b;
    b = a % b;
    a = temp;
  }
  return a;
};

-------------------------------------------------------------------------
RECURSION

15. Print name 5 times
let count = 0;
const printName = () => {
  if (count === 5) return;
  console.log("Reema");
  count++;
  printName();
};
printName();

-------------------------------------------------------------------------
16. Print from 1 to N by backtracking (calling fun first & then printing value later)
const printNumber = (i, n) => {
  if (i < 1) return;
  printNumber(i - 1, n);
  console.log(i);
};
printNumber(3, 3);

-------------------------------------------------------------------------
17. Print from N to 1
const printNum = (i, n) => {
  if (n < 1) return;
  console.log(n);
  printNum(i, n - 1);
};
printNum(3, 3);

-------------------------------------------------------------------------
18. Sum of 1st n numbers
const sumOf = (n) => {
  if (n === 0) return 0;
  return n + sumOf(n - 1);
};
console.log(sumOf(3));

-------------------------------------------------------------------------
19. Factorial of N
const factOf = (n) => {
  if (n === 0) return 1;
  return n * factOf(n - 1);
};
console.log(factOf(3));

-------------------------------------------------------------------------
20. Reverse an array
const reverseArray = (arr, left = 0, right = arr.length - 1) => {
  if (left >= right) return;
  [arr[left], arr[right]] = [arr[right], arr[left]];
  reverseArray(arr, left + 1, right - 1);
};
let arr = [1, 2, 3, 4, 5];
reverseArray(arr);
console.log(arr);

-------------------------------------------------------------------------
21. A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
var isPalindrome = function (s) {
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (left < right && !isAlphanumeric(s[left])) {
      left++;
    }
    while (left < right && !isAlphanumeric(s[right])) {
      right--;
    }
    if (s[left].toLowerCase() !== s[right].toLowerCase()) {
      return false;
    }
    left++;
    right--;
  }
  return true;
};
const isAlphanumeric = (char) => {
  return (
    (char >= "a" && char <= "z") ||
    (char >= "A" && char <= "Z") ||
    (char >= "0" && char <= "9")
  );
};

-------------------------------------------------------------------------
22. Fibonacci number
const fib = (n, memo = {}) => {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
};
console.log(fib(4));

-------------------------------------------------------------------------
ARRAY EASY

23. Largest element in an array
const findLargest = (arr) => {
  if (arr.length === 0) return null;
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
};
const arr = [3, 7, 2, 9, 4];
console.log(findLargest(arr));

-------------------------------------------------------------------------
24. Find Second Smallest and Second Largest Element in an array
const findSecondSmallestAndLargest = (arr) => {
  if (arr.length < 2) {
    return "Array must have at least two elements";
  }
  let smallest = Infinity,
    secondSmallest = Infinity;
  let largest = -Infinity,
    secondLargest = -Infinity;
  for (let num of arr) {
    // For smallest
    if (num < smallest) {
      secondSmallest = smallest;
      smallest = num;
    } else if (num > smallest && num < secondSmallest) {
      secondSmallest = num;
    }
    // For largest
    if (num > largest) {
      secondLargest = largest;
      largest = num;
    } else if (num < largest && num > secondLargest) {
      secondLargest = num;
    }
  }
  return {
    secondSmallest,
    secondLargest,
  };
};
// Example
const arr = [4, 2, 7, 1, 9, 5];
console.log(findSecondSmallestAndLargest(arr));

-------------------------------------------------------------------------
25. Check if Array Is Sorted and Rotated
const check = (nums) => {
    let drops = 0;
    const n = nums.length;
    for (let i = 0; i < n; i++) {
        if (nums[i] > nums[(i + 1) % n]) {
            drops++;
            if (drops > 1) return false;
        }
    }
    return true;
};
console.log(check([3, 4, 5, 1, 2]))

-------------------------------------------------------------------------
26. Remove Duplicates from Sorted array
const removeDuplicates = (nums) => {
    let i = 0;
    for(let j = 1; j < nums.length; j++){
        if(nums[i] !== nums[j]){
            i++
            nums[i] = nums[j]
        }
    }
    return i+1
};
console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))

-------------------------------------------------------------------------
27. Rotate Array to right by k steps
const rotate = (nums, k) => {
  const n = nums.length;
  k = k % n;
  reverse(nums, 0, n - 1);
  reverse(nums, 0, k - 1);
  reverse(nums, k, n - 1);
  // If i want to rotate to left
  // reverse(nums, 0, k - 1);
  // reverse(nums, k, n - 1);
  // reverse(nums, 0, n - 1);
  return nums;
};
const reverse = (arr, left, right) => {
  while (left < right) {
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++;
    right--;
  }
};
console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));

-------------------------------------------------------------------------
28. Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
const moveZeroes = (nums) => {
  let i = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] !== 0) {
      nums[i] = nums[j];
      i++;
    }
  }
  for (let j = i; j < nums.length; j++) {
    nums[j] = 0;
  }
  return nums;
};
console.log(moveZeroes([0, 1, 3, 0, 0, 12]));

-------------------------------------------------------------------------
29. Given an array of integers nums and an integer target, find the smallest index (0 based indexing) where the target appears in the array. If the target is not found in the array, return -1.
const linearSearchUnSorted = (arr, num) => {
  for (let j = 0; j < arr.length; j++) {
    if (arr[j] === num) return j;
  }
  return -1;
};
console.log(linearSearchUnSorted([3, 2, 5, 7, 8, 4], 5));
const linearSearchSorted = (arr, num) => {
  let left = 0,
    right = arr.length - 1;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === num) return mid;
    else if (arr[mid] < num) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
};
console.log(linearSearchSorted([1, 2, 5, 7, 8, 10, 12], 5));

-------------------------------------------------------------------------
30. Given two sorted arrays, arr1, and arr2 of size n and m. Find the union of two sorted arrays. The union of two arrays can be defined as the common and distinct elements in the two arrays.
const findUnion = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const unionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
    }
    else if (arr2[j] < arr1[i]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
        unionArr.push(arr2[j]);
      }
      j++;
    }
    else {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  while (i < arr1.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
      unionArr.push(arr1[i]);
    }
    i++;
  }
  while (j < arr2.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
      unionArr.push(arr2[j]);
    }
    j++;
  }
  return unionArr;
};
const arr1 = [1, 1, 2, 3, 4, 5];
const arr2 = [2, 3, 4, 4, 5, 6];
console.log(findUnion(arr1, arr2));
const findIntersection = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const intersectionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      i++;
    } else if (arr2[j] < arr1[i]) {
      j++;
    } else {
      if (
        intersectionArr.length === 0 ||
        intersectionArr[intersectionArr.length - 1] !== arr1[i]
      ) {
        intersectionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  return intersectionArr;
};
const arrA = [1, 2, 2, 3, 5];
const arrB = [2, 3, 3, 5, 7];
console.log(findIntersection(arrA, arrB));

-------------------------------------------------------------------------
31. Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
const missingNumber = (nums) => {
  let n = nums.length;
  let sum = (n * (n + 1)) / 2;
  let arrSum = 0;
  for (let i = 0; i < n; i++) {
    arrSum += nums[i];
  }
  return sum - arrSum;
};
console.log(missingNumber([3, 0, 1]));
const missingNumberXor = (nums) => {
  let xor = nums.length;
  for (let i = 0; i < nums.length; i++) {
    xor ^= i ^ nums[i];
  }
  return xor;
};
console.log(missingNumberXor([3, 0, 1]));

-------------------------------------------------------------------------
32. Given a binary array nums, return the maximum number of consecutive 1's in the array.
const findMaxConsecutiveOnes = (nums) => {
  let i = 0,
    max = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] === 1) {
      i++;
      if (i > max) {
        max = i;
      }
    } else {
      i = 0;
    }
  }
  return max;
};
console.log([1, 1, 0, 0, 1, 1, 1, 0]);

-------------------------------------------------------------------------
33. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
const singleNumber = (nums) => {
  let xor = 0;
  for (let i = 0; i < nums.length; i++) {
    xor ^= nums[i];
  }
  return xor;
};
console.log(singleNumber([4, 1, 2, 1, 2]));

-------------------------------------------------------------------------
ARRAY MEDIUM

35. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
const twoSumHash = (nums, target) => {
  let hashMap = new Map();
  for (let i = 0; i < nums.length; i++) {
    if (hashMap.has(nums[i])) return [hashMap.get(nums[i]), i];
    hashMap.set(target - nums[i], i);
  }
};
console.log(twoSumHash([2, 7, 11, 15], 9));
const twoSum = (nums, target) => {
  let obj = {};
  for (let i = 0; i < nums.length; i++) {
    if (obj[nums[i]] !== undefined) return [obj[nums[i]], i];
    obj[target - nums[i]] = i;
  }
};
console.log(twoSum([2, 7, 11, 15], 9));

-------------------------------------------------------------------------
36. Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
const sortColors = (nums) => {
  let low = 0,
    mid = 0,
    high = nums.length - 1;
  while (mid <= high) {
    if (nums[mid] === 0) {
      [nums[mid], nums[low]] = [nums[low], nums[mid]];
      low++;
      mid++;
    } else if (nums[mid] === 1) {
      mid++;
    } else {
      [nums[mid], nums[high]] = [nums[high], nums[mid]];
      high--;
    }
  }
};
console.log(sortColors([2, 0, 2, 1, 1, 0]));

-------------------------------------------------------------------------
37. Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
const majorityElement = (arr) => {
  let majority = Math.ceil(arr.length / 2);
  let obj = {};
  for (let i = 0; i < arr.length; i++) {
    obj[arr[i]] = (obj[arr[i]] || 0) + 1;
  }
  for (let elt in obj) {
    if (obj[elt] >= majority) {
      return +elt;
    }
  }
};
console.log(majorityElement([2,2,1,1,1,2,2]));
// Boyer-Moore's Voting Algo
const majorityElementOp = (arr) => {
  let count = 0;
  let el;
  for (let i = 0; i < arr.length; i++) {
    if (count === 0) {
      el = arr[i];
      count = 1;
    } else if (arr[i] === el) {
      count++;
    } else {
      count--;
    }
  }
  let maxCount = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === el) maxCount++;
  }

  if (maxCount > arr.length / 2) return el;
};
console.log(majorityElementOp([2, 2, 1, 1, 1, 2, 2]));

-------------------------------------------------------------------------
38. Given an integer array nums, find the subarray with the largest sum, and return its sum.
// Kadane’s Algo
const maxSubArray = (nums) => {
  let maxSum = nums[0],
    currSum = 0,
    start = 0,
    startIdx = 0,
    endIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    currSum += nums[i];
    if (currSum > maxSum) {
      maxSum = currSum;
      startIdx = start;
      endIdx = i;
    }
    if (currSum < 0) {
      currSum = 0;
      start = i + 1;
    }
  }
  for (let i = startIdx; i <= endIdx; i++) {
    console.log(nums[i]);
  }
  return maxSum;
};
console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));

-------------------------------------------------------------------------
39. You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0
const maxProfit = function (prices) {
  let profit = 0,
    mini = prices[0];
  for (let i = 1; i < prices.length; i++) {
    let max = prices[i] - mini;
    if (max > profit) profit = max;
    if (prices[i] < mini) mini = prices[i];
  }
  return profit;
};
console.log(maxProfit([7, 1, 5, 3, 6, 4]));