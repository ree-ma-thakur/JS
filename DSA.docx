PATTERNS

1.  ****
    ****
    ****
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
2.  *
    **
    ***
    ****
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i <= n; i++){
        for(let j = 0; j < i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
3.  1
    12
    123
    1234
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
4.  1
    22
    333
    4444
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j <= i; j++){
            str += i+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
5.  ****
    ***
    **
    *
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += '*'
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
6.  1234
    123
    12
    1
const printPattern = (n) => {
    let str = ''
    for(let i = 0; i < n; i++){
        for(let j = 0; j < n-i; j++){
            str += j+1
        }
        str += '\n'
    }
    return str
}
console.log(printPattern(4))

-------------------------------------------------------------------------
7.    *  
     *** 
    *****
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < 3; i++) {
        for (let j = 1; j <= 3 * 2 - 1; j++) {
            if (j < 3 - i || j > 3 + i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
8.  ***** 
     *** 
      *
const printPattern = (n) => {
    let str = '';
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n * 2 - 1; j++) {
            if (j < i || j >= n * 2 - 1 - i) {
                str += ' ';
            } else {
                str += '*';
            }
        }
        str += '\n';
    }
    return(str);
}
console.log(printPattern(3))

-------------------------------------------------------------------------
BASIC MATHS

9. Count the digits
const countDigits = (num) => {
    let count = 0;
    while(num > 0){
        count++;
        num = Math.floor(num/10)
    }
    return count
}
console.log(countDigits(24234))
TC: O(logn); SC: O(1)
const countDigitsLog = (num) => {
    return Math.floor(Math.log10(num))+1
}
console.log(countDigitsLog(24234))
TC: O(1); SC: O(1)

-------------------------------------------------------------------------
10.0 Reverse number
var reverse = function (x) {
  let num = 0,
    sign = x > 0 ? 1 : -1;
  x = Math.abs(x);
  while (x > 0) {
    let lastDigit = x % 10;
    x = Math.floor(x / 10);
    num = num * 10 + lastDigit;
  }
  if (num > Math.pow(2, 31) - 1) {
    return 0;
  }
  return num * sign;
};
TC: O(logn); SC: O(1)
10.1 Pallindrome number
var isPalindrome = function(x) {
    if(x<0) return false
    let num = x, reverseNum = 0
    while(num>0){
        let lastDigit = num % 10;
        num = Math.floor(num/10)
        reverseNum = (reverseNum*10) + lastDigit
    }
    return reverseNum === x
};
TC: O(logn); SC: O(1)

-------------------------------------------------------------------------
11. Armstrong number
const checkArmstrong = (num) => {
  let dup = num;
  let digits = Math.floor(Math.log10(num)) + 1;
  let sum = 0;
  while (dup > 0) {
    let lastDigit = dup % 10;
    dup = Math.floor(dup / 10);
    sum += Math.pow(lastDigit, digits);
  }
  return sum === num;
};
TC: O(logn); SC: O(1)

-------------------------------------------------------------------------
12. Print Divisors
const printDivisors = (num) => {
    for(let i = 1; i <= num; i++){
        if(num % i === 0) console.log(i)
    }
}
TC: O(n); SC: O(1)
printDivisors(36)
const printDivisorsSqrt = (num) => {
  // if sorted ans is not required we can skip array & can directly use console.log
  let small = [],
    large = [];
  // for(let i = 1; i <= Math.sqrt(num); i++){
  for (let i = 1; i * i <= num; i++) {
    if (num % i === 0) {
      small.push(i);
      if (num / i !== i) large.push(num / i);
    }
  }
  for (a of small) console.log(a);
  for (let b = large.length - 1; b > 0; b--) console.log(large[b]);
};
printDivisorsSqrt(36);
TC: O(√n); SC: O(√n)

-------------------------------------------------------------------------
13. Prime number
const isPrime = (n) => {
  if (n <= 1) return false;
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) return false;
  }
  return true;
};
TC: O(√n); SC: O(1)

-------------------------------------------------------------------------
14. GCD/HCF => using Euclidean Algorithm
const hcf = (a, b) => {
  while (a > 0 && b > 0) {
    if (a > b) a = a % b;
    if (b > a) b = b % a;
  }
  if (a === 0) return b;
  return a;
};
console.log(hcf(20, 40));
TC: O(log min(a, b)); SC: O(1)
const gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));
TC: O(log min(a, b)); SC: O(log min(a, b))
const gcdBest = (a, b) => {
  a = Math.abs(a);
  b = Math.abs(b);
  while (b !== 0) {
    let temp = b;
    b = a % b;
    a = temp;
  }
  return a;
};
TC: O(log min(a, b)); SC: O(1)

-------------------------------------------------------------------------
RECURSION

15. Print name 5 times
let count = 0;
const printName = () => {
  if (count === 5) return;
  console.log("Reema");
  count++;
  printName();
};
printName();

-------------------------------------------------------------------------
16. Print from 1 to N by backtracking (calling fun first & then printing value later)
const printNumber = (i, n) => {
  if (i < 1) return;
  printNumber(i - 1, n);
  console.log(i);
};
printNumber(3, 3);

-------------------------------------------------------------------------
17. Print from N to 1
const printNum = (i, n) => {
  if (n < 1) return;
  console.log(n);
  printNum(i, n - 1);
};
printNum(3, 3);

-------------------------------------------------------------------------
18. Sum of 1st n numbers
const sumOf = (n) => {
  if (n === 0) return 0;
  return n + sumOf(n - 1);
};
console.log(sumOf(3));

-------------------------------------------------------------------------
19. Factorial of N
const factOf = (n) => {
  if (n === 0) return 1;
  return n * factOf(n - 1);
};
console.log(factOf(3));

-------------------------------------------------------------------------
20. Reverse an array
const reverseArray = (arr, left = 0, right = arr.length - 1) => {
  if (left >= right) return;
  [arr[left], arr[right]] = [arr[right], arr[left]];
  reverseArray(arr, left + 1, right - 1);
};
let arr = [1, 2, 3, 4, 5];
reverseArray(arr);
console.log(arr);

-------------------------------------------------------------------------
21. A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
var isPalindrome = function (s) {
  let left = 0,
    right = s.length - 1;
  while (left < right) {
    while (left < right && !isAlphanumeric(s[left])) {
      left++;
    }
    while (left < right && !isAlphanumeric(s[right])) {
      right--;
    }
    if (s[left].toLowerCase() !== s[right].toLowerCase()) {
      return false;
    }
    left++;
    right--;
  }
  return true;
};
const isAlphanumeric = (char) => {
  return (
    (char >= "a" && char <= "z") ||
    (char >= "A" && char <= "Z") ||
    (char >= "0" && char <= "9")
  );
};

-------------------------------------------------------------------------
22. Fibonacci number
const fib = (n, memo = {}) => {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
};
console.log(fib(4));

-------------------------------------------------------------------------
SORTING

1. Selection sort
const selectionSort = (arr) => {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    // Assume the first unsorted element is the minimum
    let minIndex = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j; // Update index if a smaller element is found
      }
    }
    // Swap the found minimum element with the first unsorted element
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  return arr;
};
const data2 = [29, 10, 14, 37, 13];
console.log("Selection Sort:", selectionSort(data2));
TC: O(n2) (Avg, Best & Worst case); SC: O(1)

-------------------------------------------------------------------------
2. Bubble Sort
const bubbleSort = (arr) => {
  let n = arr.length;
  let swapped;
  for (let i = 0; i < n - 1; i++) {
    swapped = false;
    // Inner loop: elements at the end are already sorted
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // Swap elements
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    // If no two elements were swapped by inner loop, then break
    if (!swapped) break;
  }
  return arr;
};
const data = [64, 34, 25, 12, 22, 11, 90];
console.log("Bubble Sort:", bubbleSort(data));
Tc: O(n2) - Worst & Average; O(n) - Best case

-------------------------------------------------------------------------
3. Insertion sort
const insertionSort = (arr) => {
  for (let i = 1; i < arr.length; i++) {
    let j = i - 1;
    let key = arr[i];
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
};
const data = [64, 34, 25, 12, 22, 11, 90];
console.log("Insertion Sort:", insertionSort(data));

-------------------------------------------------------------------------
4. Merge Sort
const merge = (arr, low, mid, high) => {
  let temp = [], left = low, right = mid+1
  while(left<=mid&& right<=high){
    if(arr[left]<=arr[right]){
      temp.push(arr[left])
      left++
    }else{
      temp.push(arr[right])
      right++
    }
  }
  while(left<=mid){
    temp.push(arr[left])
    left++
  }
  while(right<=high){
    temp.push(arr[right])
    right++
  }
  for(let i =low; i<high;i++){
    arr[i] = temp[i - low]
  }
}
const mergeSort = (arr, low = 0, high = arr.length-1) => {
  if(low>=high) return
  let mid = Math.floor((low+high)/2)
  mergeSort(arr, low, mid)
  mergeSort(arr, mid+1, high)
  merge(arr, low, mid, high)
}
let arr = [3,2,8,5,1,4,23]
mergeSort(arr)
console.log(arr)

-------------------------------------------------------------------------
5. Quick Sort

-------------------------------------------------------------------------
ARRAY EASY

23. Largest element in an array
const findLargest = (arr) => {
  if (arr.length === 0) return null;
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
};
const arr = [3, 7, 2, 9, 4];
console.log(findLargest(arr));
TC: O(n); SC: O(1)
const largestInSorted = (arr) => {
  if (!arr.length) return null;
  return arr[arr.length - 1];
};
TC: O(1); SC: O(1)

-------------------------------------------------------------------------
24. Find Second Smallest and Second Largest Element in an array
const findSecondSmallestAndLargest = (arr) => {
  if (arr.length < 2) {
    return "Array must have at least two elements";
  }
  let smallest = Infinity,
    secondSmallest = Infinity;
  let largest = -Infinity,
    secondLargest = -Infinity;
  for (let num of arr) {
    // For smallest
    if (num < smallest) {
      secondSmallest = smallest;
      smallest = num;
    } else if (num > smallest && num < secondSmallest) {
      secondSmallest = num;
    }
    // For largest
    if (num > largest) {
      secondLargest = largest;
      largest = num;
    } else if (num < largest && num > secondLargest) {
      secondLargest = num;
    }
  }
  return {
    secondSmallest: secondSmallest === Infinity ? null : secondSmallest,
    secondLargest: secondLargest === -Infinity ? null : secondLargest,
  };
};
const arr = [4, 2, 7, 1, 9, 5];
console.log(findSecondSmallestAndLargest(arr));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
25. Check if Array Is Sorted and Rotated
const check = (nums) => {
  if (!nums.length) return false;
  let drops = 0;
  const n = nums.length;
  for (let i = 0; i < n; i++) {
    if (nums[i] > nums[(i + 1) % n]) {
      drops++;
      if (drops > 1) return false;
    }
  }
  return true;
};
console.log(check([3, 4, 5, 1, 2]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
26. Remove Duplicates from Sorted array
const removeDuplicates = (nums) => {
    let i = 0;
    for(let j = 1; j < nums.length; j++){
        if(nums[i] !== nums[j]){
            i++
            nums[i] = nums[j]
        }
    }
    return i+1
};
console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
27. Rotate Array to right by k steps
const rotate = function (nums, k) {
  const n = nums.length;
  if (!n || n === 1) return nums;
  k = k % n;
  if (k === 0) return nums;
  const reverse = (arr, left, right) => {
    while (left < right) {
      [arr[left], arr[right]] = [arr[right], arr[left]];
      right--;
      left++;
    }
  };
  reverse(nums, 0, nums.length - 1);
  reverse(nums, 0, k - 1);
  reverse(nums, k, nums.length - 1);
  // If i want to rotate to left
  // reverse(nums, 0, k - 1);
  // reverse(nums, k, n - 1);
  // reverse(nums, 0, n - 1);
};
console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
28. Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
const moveZeroes = (nums) => {
  const n = nums.length;
  if (n === 0 || n === 1) return nums;
  let i = 0;
  for (let j = 0; j < n; j++) {
    if (nums[j] !== 0) {
      nums[i] = nums[j];
      i++;
    }
  }
  while (i < n) {
    nums[i] = 0;
    i++;
  }
  return nums;
};
console.log(moveZeroes([0, 1, 3, 0, 0, 12]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
29. Given an array of integers nums and an integer target, find the smallest index (0 based indexing) where the target appears in the array. If the target is not found in the array, return -1.
const linearSearchUnSorted = (arr, num) => {
  for (let j = 0; j < arr.length; j++) {
    if (arr[j] === num) return j;
  }
  return -1;
};
console.log(linearSearchUnSorted([3, 2, 5, 7, 8, 4], 5));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
30. Given two sorted arrays, arr1, and arr2 of size n and m. Find the union of two sorted arrays. The union of two arrays can be defined as the common and distinct elements in the two arrays.
const findUnion = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const unionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
    }
    else if (arr2[j] < arr1[i]) {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
        unionArr.push(arr2[j]);
      }
      j++;
    }
    else {
      if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
        unionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  while (i < arr1.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr1[i]) {
      unionArr.push(arr1[i]);
    }
    i++;
  }
  while (j < arr2.length) {
    if (unionArr.length === 0 || unionArr[unionArr.length - 1] !== arr2[j]) {
      unionArr.push(arr2[j]);
    }
    j++;
  }
  return unionArr;
};
const arr1 = [1, 1, 2, 3, 4, 5];
const arr2 = [2, 3, 4, 4, 5, 6];
console.log(findUnion(arr1, arr2));
TC: O(n + m); SC: O(n + m)
const findIntersection = (arr1, arr2) => {
  let i = 0;
  let j = 0;
  const intersectionArr = [];
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      i++;
    } else if (arr2[j] < arr1[i]) {
      j++;
    } else {
      if (
        intersectionArr.length === 0 ||
        intersectionArr[intersectionArr.length - 1] !== arr1[i]
      ) {
        intersectionArr.push(arr1[i]);
      }
      i++;
      j++;
    }
  }
  return intersectionArr;
};
const arrA = [1, 2, 2, 3, 5];
const arrB = [2, 3, 3, 5, 7];
console.log(findIntersection(arrA, arrB));
TC: O(n + m); SC: O(min(n, m))

-------------------------------------------------------------------------
31. Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
const missingNumber = (nums) => {
  if (nums.length === 0) return 0;
  let n = nums.length;
  let sum = (n * (n + 1)) / 2;
  let arrSum = 0;
  for (let i = 0; i < n; i++) {
    arrSum += nums[i];
  }
  return sum - arrSum;
};
console.log(missingNumber([3, 0, 1]));
TC: O(n); SC: O(1)
const missingNumberXor = (nums) => {
  if (nums.length === 0) return 0;
  let xor = nums.length;
  for (let i = 0; i < nums.length; i++) {
    xor ^= nums[i];
    xor ^= i;
  }
  return xor;
};
console.log(missingNumberXor([3, 0, 1]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
32. Given a binary array nums, return the maximum number of consecutive 1's in the array.
const findMaxConsecutiveOnes = (nums) => {
  if (!nums.length) return 0;
  let i = 0,
    max = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] === 1) {
      i++;
      if (i > max) {
        max = i;
      }
    } else {
      i = 0;
    }
  }
  return max;
};
console.log([1, 1, 0, 0, 1, 1, 1, 0]);
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
33. Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
const singleNumber = (nums) => {
  if (!Array.isArray(nums) || nums.length === 0) return null;
  let xor = 0;
  for (let i = 0; i < nums.length; i++) {
    xor ^= nums[i];
  }
  return xor;
};
console.log(singleNumber([4, 1, 2, 1, 2]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
34. Given an array nums of size n and an integer k, find the length of the longest sub-array that sums to k. If no such sub-array exists, return 0.
const longestSubArrPositiveNumbersOnly = (arr, k) => {
  if (!Array.isArray(arr) || arr.length === 0) return 0;
  let left = 0;
  let sum = 0;
  let maxLen = 0;
  for (let right = 0; right < arr.length; right++) {
    sum += arr[right];
    while (sum > k) {
      sum -= arr[left];
      left++;
    }
    if (sum === k) {
      maxLen = Math.max(maxLen, right - left + 1);
    }
  }
  return maxLen;
};
console.log(longestSubArrPositiveNumbersOnly([10, 5, 2, 7, 1, 9], 15));
TC: O(n); SC: O(1)
const longestSubArrPosNegNumbers = (arr, k) => {
  if (!Array.isArray(arr) || arr.length === 0) return 0;
  let map = new Map();
  let sum = 0;
  let maxLen = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
    if (sum === k) {
      maxLen = i + 1;
    }
    if (map.has(sum - k)) {
      maxLen = Math.max(maxLen, i - map.get(sum - k));
    }
    if (!map.has(sum)) {
      map.set(sum, i);
    }
  }
  return maxLen;
};
console.log(longestSubArrPosNegNumbers([-1, 1, 1], 1));
TC: O(n); SC: O(n)

-------------------------------------------------------------------------
ARRAY MEDIUM

35. Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
const twoSum = (nums, target) => {
  let hashMap = new Map();
  for (let i = 0; i < nums.length; i++) {
    let sum = target - nums[i];
    if (hashMap.has(sum)) return [hashMap.get(sum), i];
    hashMap.set(nums[i], i);
  }
  return [-1, -1];
};
console.log(twoSum([2, 7, 11, 15], 9));
TC: O(n); SC: O(n)

-------------------------------------------------------------------------
36. Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
const sortColors = (nums) => {
  let low = 0,
    mid = 0,
    high = nums.length - 1;
  while (mid <= high) {
    if (nums[mid] === 0) {
      [nums[mid], nums[low]] = [nums[low], nums[mid]];
      low++;
      mid++;
    } else if (nums[mid] === 1) {
      mid++;
    } else {
      [nums[mid], nums[high]] = [nums[high], nums[mid]];
      high--;
    }
  }
};
console.log(sortColors([2, 0, 2, 1, 1, 0]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
37. Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
const majorityElement = (arr) => {
  let majority = Math.ceil(arr.length / 2);
  let obj = {};
  for (let i = 0; i < arr.length; i++) {
    obj[arr[i]] = (obj[arr[i]] || 0) + 1;
  }
  for (let elt in obj) {
    if (obj[elt] >= majority) {
      return +elt;
    }
  }
};
console.log(majorityElement([2,2,1,1,1,2,2]));
// Boyer-Moore's Voting Algo
const majorityElementOp = (arr) => {
  let count = 0;
  let el;
  for (let i = 0; i < arr.length; i++) {
    if (count === 0) {
      el = arr[i];
      count = 1;
    } else if (arr[i] === el) {
      count++;
    } else {
      count--;
    }
  }
  let maxCount = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === el) maxCount++;
  }

  if (maxCount > arr.length / 2) return el;
};
console.log(majorityElementOp([2, 2, 1, 1, 1, 2, 2]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
38. Given an integer array nums, find the subarray with the largest sum, and return its sum.
// Kadane’s Algo
const maxSubArray = (nums) => {
  let sum = 0,
    max = nums[0],
    start = 0,
    startIdx = 0,
    endIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (sum > max) {
      max = sum;
      startIdx = start;
      endIdx = i;
    }
    if (sum < 0) {
      sum = 0;
      start = i + 1;
    }
  }
  return { max, startIdx, endIdx };
};
console.log(maxSubArray([-2, -3, -5, -1]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
39. You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0
const maxProfit = function (prices) {
  if (prices.length < 2) return 0;
  let profit = 0,
    mini = prices[0];
  for (let i = 1; i < prices.length; i++) {
    let max = prices[i] - mini;
    if (max > profit) profit = max;
    if (prices[i] < mini) mini = prices[i];
  }
  return profit;
};
console.log(maxProfit([7, 1, 5, 3, 6, 4]));
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
40. You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers. You should return the array of nums such that the array follows the given conditions: Every consecutive pair of integers have opposite signs; For all integers with the same sign, the order in which they were present in nums is preserved; The rearranged array begins with a positive integer; Return the modified array after rearranging the elements to satisfy the aforementioned conditions;
const rearrangeArray = (nums) => {
  let newArray = new Array(nums.length).fill(0);
  let oddIdx = 1,
    evenIdx = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0) {
      newArray[oddIdx] = nums[i];
      oddIdx += 2;
    } else {
      newArray[evenIdx] = nums[i];
      evenIdx += 2;
    }
  }
  return newArray;
};
console.log(rearrangeArray([3, 1, -2, -5, 2, -4]));
TC: O(n); SC: O(n)
const rearrangeArrayInPlace = (nums) => {
  let pos = 0, neg = 1
  while (pos < nums.length && neg < nums.length) {
    if (nums[pos] > 0) pos += 2
    else if (nums[neg] < 0) neg += 2
    else {
      [nums[pos], nums[neg]] = [nums[neg], nums[pos]]
      pos += 2
      neg += 2
    }
  }
  return nums
}
console.log(rearrangeArrayInPlace([3,1,-2,-5,2,-4]))
TC: O(n); SC: O(1)

-------------------------------------------------------------------------
41. A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
const nextPermutation = (nums) => {
  let breakIdx = -1;
  const reverseArr = (arr, start, end) => {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  };
  for (let i = nums.length - 2; i >= 0; i--) {
    if (nums[i] < nums[i + 1]) {
      breakIdx = i;
      break;
    }
  }
  if (breakIdx === -1) {
    reverseArr(nums, 0, nums.length - 1);
    return nums;
  }
  for (let i = nums.length - 1; i >= breakIdx; i--) {
    if (nums[i] > nums[breakIdx]) {
      [nums[i], nums[breakIdx]] = [nums[breakIdx], nums[i]];
      break;
    }
  }
  reverseArr(nums, breakIdx + 1, nums.length - 1);
  return nums;
};
console.log(nextPermutation([3, 2, 1]));
const nextPermutationOp = (nums) => {
  let i = nums.length - 2;
  const reverseArr = (arr, start, end) => {
    while (start < end) {
      [arr[start], arr[end]] = [arr[end], arr[start]];
      start++;
      end--;
    }
  };
  // Step 1: Find the first decreasing element from the right
  while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
  }
  // Step 2: If pivot is found, find the element to swap with
  if (i >= 0) {
    let j = nums.length - 1;
    while (nums[j] <= nums[i]) {
      j--;
    }
    swap(nums, i, j);
  }
  // Step 3: Reverse the suffix to get the next lexicographical smallest
  reverse(nums, i + 1, nums.length - 1);
  return nums;
};

-------------------------------------------------------------------------
42. Leaders in an Array
const leaders = (nums) => {
  if (nums.length === 0) return [];
  let leaders = [];
  let maxFromRight = nums[nums.length - 1];
  leaders.push(maxFromRight);
  for (let i = nums.length - 2; i >= 0; i--) {
    if (nums[i] > maxFromRight) {
      maxFromRight = nums[i];
      leaders.push(nums[i]);
    }
  }
  // If order need to be maintained then reverse the array if needed
  return leaders.reverse();
};
console.log(leaders([13, 7, 5, 12, 1]));
TC: O(n); SC: O(n)

-------------------------------------------------------------------------
43. Given an array nums of n integers. Return the length of the longest sequence of consecutive integers. The integers in this sequence can appear in any order.
const longestSequence = (arr) => {
  if (arr.length === 0) return 0;
  const newSet = new Set(arr);
  let longest = 1;
  for (let num of newSet) {
    if (!newSet.has(num - 1)) {
      let currentNum = num;
      let currentStreak = 1;
      while (newSet.has(currentNum + 1)) {
        currentNum += 1;
        currentStreak += 1;
      }
      if (currentStreak > longest) longest = currentStreak;
    }
  }
  return longest;
};
console.log(longestSequence([100, 4, 200, 1, 3, 2]));
TC: O(n); SC: O(n)

-------------------------------------------------------------------------
44. Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.
const setZeroes = (arr) => {
  if (!arr.length || !arr[0].length) return arr;
  let m = arr.length;
  let n = arr[0].length;
  let firstColZero = 1;
  for (let i = 0; i < m; i++) {
    if (arr[i][0] === 0) firstColZero = 0;
    for (let j = 1; j < n; j++) {
      if (arr[i][j] === 0) {
        arr[i][0] = 0;
        arr[0][j] = 0;
      }
    }
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      if (arr[i][0] === 0 || arr[0][j] === 0) {
        arr[i][j] = 0;
      }
    }
  }
  if (arr[0][0] === 0) {
    for (let j = 0; j < n; j++) arr[0][j] = 0;
  }
  if (firstColZero === 0) {
    for (let i = 0; i < m; i++) arr[i][0] = 0;
  }
  return arr;
};
console.log(
  setZeroes([
    [1, 1, 1, 1],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 1],
  ]),
);
TC: O(m*n); SC: O(1)

-------------------------------------------------------------------------
45. You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
const rotate = (arr) => {
  if (!arr.length || arr.some((row) => row.length !== arr.length)) {
    return arr;
  }
  for (let i = 0; i < arr.length; i++) {
    for (j = i + 1; j < arr.length; j++) {
      [arr[i][j], arr[j][i]] = [arr[j][i], arr[i][j]];
    }
  }
  for (i = 0; i < arr.length; i++) {
    arr[i].reverse();
  }
  return arr;
};
console.log(
  rotate([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
  ]),
);
TC: O(n2); SC: O(1)

-------------------------------------------------------------------------
46. Given a Matrix, print the given matrix in spiral order.
const spiralOrder = (matrix) => {
  if (!matrix.length || !matrix[0].length) return [];
  let top = 0,
    left = 0,
    right = matrix[0].length - 1,
    bottom = matrix.length - 1,
    arr = [];
  while (top <= bottom && left <= right) {
    for (let i = left; i <= right; i++) {
      arr.push(matrix[top][i]);
    }
    top++;
    for (let i = top; i <= bottom; i++) {
      arr.push(matrix[i][right]);
    }
    right--;
    if (top <= bottom) {
      for (let i = right; i >= left; i--) {
        arr.push(matrix[bottom][i]);
      }
      bottom--;
    }
    if (left <= right) {
      for (let i = bottom; i >= top; i--) {
        arr.push(matrix[i][left]);
      }
      left++;
    }
  }
  return arr;
};
console.log(
  spiralOrder([
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
  ]),
);

-------------------------------------------------------------------------
47. Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. A subarray is a contiguous non-empty sequence of elements(positive & negative) within an array.
const subarraySum = (nums, k) => {
  if (nums.length === 0) return 0;
  const hashMap = new Map();
  let sum = 0,
    count = 0;
  hashMap.set(0, 1);
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i];
    if (hashMap.has(sum - k)) {
      count += hashMap.get(sum - k);
    }
    hashMap.set(sum, (hashMap.get(sum) || 0) + 1);
  }
  return count;
};
console.log([1, 1, 1], 2);
TC: O(n); SC: O(n)

-------------------------------------------------------------------------
ARRAY HARD

48. Pascal’s Triangle
a. Find value at row = r, column = c (1-indexed)
const pascalValue = (r, c) => {
  if (c < 1 || c > r) return 0;
  let val = 1;
  (r--, c--);
  for (i = 0; i < c; i++) {
    val = (val * (r - i)) / (i + 1);
  }
  return val;
};
console.log(pascalValue(5, 3));
b. Find nth row of Pascal’s Triangle
const getNthRow = (N) => {
  let row = [];
  let val = 1;
  row.push(val);
  for (let i = 1; i < N; i++) {
    val = (val * (N - i)) / i;
    row.push(val);
  }
  return row;
};
console.log(getNthRow(5));
c. Generate Pascal’s Triangle up to N rows
const pascalTriangle = (k) => {
  let triangle = [];
  for (let i = 0; i < k; i++) {
    let subArr = [];
    for (let j = 0; j <= i; j++) {
      if (j === 0 || j === i) {
        subArr.push(1);
      } else {
        subArr.push(triangle[i - 1][j - 1] + triangle[i - 1][j]);
      }
    }
    triangle.push(subArr);
  }
  return triangle;
};
console.log(pascalTriangle(5));

-------------------------------------------------------------------------
49. Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
const majorityElement = (nums) => {
  if (nums.length === 0) return [];
  let cnt1 = 0,
    cnt2 = 0,
    el1,
    el2;
  for (let i = 0; i < nums.length; i++) {
    if (cnt1 === 0 && el2 !== nums[i]) {
      el1 = nums[i];
      cnt1 = 1;
    } else if (cnt2 === 0 && el1 !== nums[i]) {
      el2 = nums[i];
      cnt2 = 1;
    } else if (el1 === nums[i]) {
      cnt1++;
    } else if (el2 === nums[i]) {
      cnt2++;
    } else {
      cnt1--;
      cnt2--;
    }
  }
  let temp1Cnt = 0,
    temp2Cnt = 0;
  for (let i = 0; i < nums.length; i++) {
    if (el1 === nums[i]) temp1Cnt++;
    if (el2 === nums[i]) temp2Cnt++;
  }
  let mini = Math.floor(nums.length / 3);
  let arr = [];
  if (temp1Cnt > mini) arr.push(el1);
  if (temp2Cnt > mini && el2 !== el1) arr.push(el2);
  return arr;
};
console.log(majorityElement([3, 2, 3]));

-------------------------------------------------------------------------
50. Three Sum
const threeSum = (nums, target) => {
  let arr = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i - 1] === nums[i]) continue;
    if (nums[i] + nums[i + 1] + nums[i + 2] > target) break;
    if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] < target)
      continue;
    let j = i + 1,
      k = nums.length - 1;
    while (j < k) {
      let sum = nums[i] + nums[j] + nums[k];
      if (sum === target) {
        arr.push([nums[i], nums[j], nums[k]]);
        j++;
        k--;
        while (j < k && nums[j] === nums[j - 1]) j++;
        while (j < k && nums[k] === nums[k + 1]) k--;
      } else if (sum > 0) {
        k--;
      } else {
        j++;
      }
    }
  }
  return arr;
};
console.log(threeSum([-1, 0, 1, 2, -1, -4], 0));

-------------------------------------------------------------------------
51. Four Sum
const fourSum = (nums, target) => {
  const arr = [];
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length - 3; i++) {
    if (i > 0 && nums[i - 1] === nums[i]) continue;
    if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) break;
    if (
      nums[i] +
        nums[nums.length - 1] +
        nums[nums.length - 2] +
        nums[nums.length - 3] <
      target
    )
      continue;
    for (let j = i + 1; j < nums.length - 2; j++) {
      if (j > i + 1 && nums[j - 1] === nums[j]) continue;
      let k = j + 1,
        l = nums.length - 1;
      while (k < l) {
        let sum = nums[i] + nums[j] + nums[k] + nums[l];
        if (sum === target) {
          arr.push([nums[i], nums[j], nums[k], nums[l]]);
          k++;
          l--;
          while (k < l && nums[k] === nums[k - 1]) k++;
          while (k < l && nums[l] === nums[l + 1]) l--;
        } else if (sum < target) {
          k++;
        } else {
          l--;
        }
      }
    }
  }
  return arr;
};
console.log(fourSum([1, 0, -1, 0, -2, 2], 0));

-------------------------------------------------------------------------
52. Count the number of subarrays with given xor K
const subarrayXor = (nums, target) => {
  let prefixXor = 0;
  let count = 0;
  let map = new Map();
  map.set(0, 1);
  for (let i = 0; i < nums.length; i++) {
    prefixXor ^= nums[i];
    if (map.has(prefixXor ^ target)) {
      count += map.get(prefixXor ^ target);
    }
    map.set(prefixXor, (map.get(prefixXor) || 0) + 1);
  }
  return count;
};
console.log([4, 2, 2, 6, 4], 6);

-------------------------------------------------------------------------
53. Merge Intervals: Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
const merge = (arr) => {
  if (!arr.length) return [];
  arr = arr.sort((a, b) => a[0] - b[0]);
  let intervals = [arr[0]];
  for (let i = 1; i < arr.length; i++) {
    let elt = intervals[intervals.length - 1];
    if (arr[i][0] <= elt[1]) elt[1] = Math.max(arr[i][1], elt[1]);
    else intervals.push(arr[i]);
  }
  return intervals;
};
console.log([
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18],
]);

-------------------------------------------------------------------------
54. Merge 2 sorted arrays without extra space. You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. The final sorted array should not be returned by the function, but instead be stored inside the array nums1
const merge = (nums1, m, nums2, n) => {
  let i = m - 1,
    j = n - 1,
    k = m + n - 1;
  while (j >= 0) {
    if (i >= 0 && nums1[i] > nums2[j]) {
      nums1[k] = nums1[i];
      i--;
    } else {
      nums1[k] = nums2[j];
      j--;
    }
    k--;
  }
  return nums1;
};
console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3));

-------------------------------------------------------------------------
55. Find the repeating and missing numbers. Given an integer array nums of size n containing values from [1, n] and each value appears exactly once in the array, except for A, which appears twice and B which is missing. Return the values A and B, as an array of size 2, where A appears in the 0-th index and B in the 1st index. You are not allowed to modify the original array.
const findMissingAndRepeating = (arr) => {
  arr.sort((a, b) => a - b);
  let repeating = -1;
  let missing = -1;
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] === arr[i - 1]) {
      repeating = arr[i];
    } else if (arr[i] > arr[i - 1] + 1) {
      missing = arr[i - 1] + 1;
    }
  }
  // edge case: missing number is n
  if (missing === -1) {
    missing = arr.length;
  }
  return { missing, repeating };
};
console.log(findMissingAndRepeating([3, 5, 4, 1, 1]));
const findMissingAndRepeatingMath = (arr) => {
  const n = arr.length;
  let sum = 0;
  let sumSq = 0;
  for (let i = 0; i < n; i++) {
    sum += arr[i];
    sumSq += arr[i] * arr[i];
  }
  let Sn = (n * (n + 1)) / 2;
  let Sn2 = (n * (n + 1) * (2 * n + 1)) / 6;
  let diff = Sn - sum; // x - y
  let diffSq = Sn2 - sumSq; // x^2 - y^2 = (x + y)(x - y)
  let sumMR = diffSq / diff; // x + y
  let missing = (diff + sumMR) / 2;
  let repeating = missing - diff;
  return { missing, repeating };
};
console.log(findMissingAndRepeatingMath([3, 5, 4, 1, 1]));

-------------------------------------------------------------------------
58. Maximum product subarray. Given an integer array nums, find a subarray that has the largest product, and return the product.
const maxProduct = (nums) => {
  let max = -Infinity,
    suffix = 1,
    prefix = 1;
  for (let i = 0; i < nums.length; i++) {
    prefix = (prefix === 0 ? 1 : prefix) * nums[i];
    suffix = (suffix === 0 ? 1 : suffix) * nums[nums.length - i - 1];
    max = Math.max(max, Math.max(suffix, prefix));
  }
  return max;
};
console.log(maxProduct([2, 3, -2, 4]));

-------------------------------------------------------------------------
BINARY SEARCH (applies only to sorted array(or rotated or sorted in any range))

59. Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
const search = (nums, target) => {
  let low = 0,
    high = nums.length - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (nums[mid] === target) return mid;
    else if (nums[mid] < target) low = mid + 1;
    else high = mid - 1;
  }
  return -1;
};
console.log(search([-1, 0, 3, 5, 9, 12]));

-------------------------------------------------------------------------
70. Single Element in Sorted Array: You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
const singleNonDuplicate = (nums) => {
  let n = nums.length;
  if (n === 1 || nums[0] !== nums[1]) return nums[0];
  if (nums[n - 1] !== nums[n - 2]) return nums[n - 1];
  let low = 1,
    high = n - 2;
  while (low <= high) {
    let mid = Math.floor((high + low) / 2);
    if (nums[mid - 1] !== nums[mid] && nums[mid] !== nums[mid + 1])
      return nums[mid];
    if (
      (mid % 2 === 1 && nums[mid] === nums[mid - 1]) ||
      (mid % 2 === 0 && nums[mid] === nums[mid + 1])
    ) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return -1;
};
console.log(singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]));

-------------------------------------------------------------------------
71. Find Peak Element: A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.
const findPeakElement = (nums) => {
  const n = nums.length;
  if (n === 1 || nums[0] > nums[1]) return 0;
  if (nums[n - 1] > nums[n - 2]) return n - 1;
  let low = 1,
    high = n - 2;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (nums[mid - 1] < nums[mid] && nums[mid] > nums[mid + 1]) return mid;
    if (nums[mid - 1] < nums[mid]) low = mid + 1;
    else high = mid - 1;
  }
  return -1;
};
console.log(findPeakElement([1, 2, 1, 3, 5, 6, 4]));

-------------------------------------------------------------------------
72. Finding Sqrt of a number: You are given a positive integer n. Your task is to find and return its square root. If ‘n’ is not a perfect square, then return the floor value of sqrt(n).
const findSqrt = (n) => {
  if (n < 2) return n;
  let low = 1,
    high = Math.floor(n / 2);
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (mid * mid === n) {
      return mid;
    }
    if (mid * mid < n) low = mid + 1;
    else high = mid - 1;
  }
  return high;
};
console.log(findSqrt(28));

-------------------------------------------------------------------------
73. Nth Root of a Number using Binary Search: Given two numbers N and M, find the Nth root of M. The nth root of a number M is defined as a number X when raised to the power N equals M. If the 'nth root is not an integer, return -1
const findNthRoot = (root, n) => {
  if (n < 2) return n;
  let low = 1,
    high = n;
  const power = (num, root, limit) => {
    let val = 1;
    for (let i = 0; i < root; i++) {
      val *= num;
      if (val > limit) return val;
    }
    return val;
  };
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    // let val = Math.pow(mid, root);
    let val = power(mid, root, n);
    if (val === n) return mid;
    if (val < n) low = mid + 1;
    else high = mid - 1;
  }
  return -1;
};
console.log(findNthRoot(3, 27));

-------------------------------------------------------------------------
74. Koko eating Bananas: Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours.
const minEatingSpeed = (piles, h) => {
  const totalHours = (minBanana) => {
    let hours = 0;
    for (let pile of piles) {
      hours += Math.ceil(pile / minBanana);
    }
    return hours;
  };
  let max = Math.max(...piles);
  let low = 1,
    high = max;
  while (low < high) {
    let mid = Math.floor((low + high) / 2);
    let hours = totalHours(mid);
    if (hours <= h) high = mid;
    else low = mid + 1;
  }
  return low;
};
console.log(minEatingSpeed([30, 11, 23, 4, 20]));

-------------------------------------------------------------------------
75. Minimum number of days to make m bouquets: You are given an integer array bloomDay, an integer m and an integer k. You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden. The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet. Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.
const minDays = (bloomDay, m, k) => {
  if (bloomDay.length < m * k) return -1;
  const isPossible = (day) => {
    let count = 0,
      bouquet = 0;
    for (let bloom of bloomDay) {
      if (bloom <= day) {
        count++;
        if (count === k) {
          bouquet++;
          count = 0;
          if (bouquet === m) return true;
        }
      } else {
        count = 0;
      }
    }
    return false;
  };
  let low = Math.min(...bloomDay),
    high = Math.max(...bloomDay);
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (isPossible(mid)) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return low;
};
console.log(minDays([1, 10, 3, 10, 2], 3, 1));

-------------------------------------------------------------------------
76. Find the smallest divisor given a threshold: Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).
const smallestDivisor = (nums, threshold) => {
  let high = Math.max(...nums),
    low = 1;
  const countSum = (divisor) => {
    let sum = 0;
    for (let num of nums) {
      sum += Math.ceil(num / divisor);
      if (sum > threshold) return sum;
    }
    return sum;
  };
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (countSum(mid) > threshold) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return low;
};
console.log(smallestDivisor([1, 2, 5, 9], 6));

-------------------------------------------------------------------------
77. Capacity to ship packages within D days: A conveyor belt has packages that must be shipped from one port to another within days days. The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.
const shipWithinDays = (weights, days) => {
  const countDays = (capacity) => {
    let countDay = 1,
      sum = 0;
    for (let weight of weights) {
      sum += weight;
      if (sum > capacity) {
        countDay++;
        if (countDay > days) return countDay;
        sum = weight;
      }
    }
    return countDay;
  };
  let low = Math.max(...weights),
    high = weights.reduce((a, b) => a + b, 0);
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (countDays(mid) > days) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return low;
};
console.log([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5);

-------------------------------------------------------------------------
78. Kth missing Positive number: Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array.
const findKthPositive = (arr, k) => {
  let low = 0,
    high = arr.length - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let missingNumbers = arr[mid] - (mid + 1);
    if (missingNumbers < k) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  // or high+1+k
  return low + k;
};
console.log(findKthPositive([2, 3, 4, 7, 11], 5));

-------------------------------------------------------------------------
79. Aggressive Cows: You are given an array 'arr' of size 'n' which denotes the position of stalls. You are also given an integer 'k' which denotes the number of aggressive cows. You are given the task of assigning stalls to 'k' cows such that the minimum distance between any two of them is the maximum possible. Find the maximum possible minimum distance.
const aggressiveCows = (arr, k) => {
  arr.sort((a, b) => a - b);
  let low = 0;
  let high = arr[arr.length - 1] - arr[0];
  const canPlace = (distance) => {
    let cows = 1;
    let lastPos = arr[0];
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] - lastPos >= distance) {
        cows++;
        lastPos = arr[i];
      }
      if (cows >= k) return true;
    }
    return false;
  };
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    if (canPlace(mid)) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return high;
};
console.log(aggressiveCows([0, 3, 4, 7, 10, 9], 4));

-------------------------------------------------------------------------
80. Split array largest sum: Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized. Return the minimized largest sum of the split. A subarray is a contiguous part of the array.
Allocate Minimum Number of Pages: Given an array ‘arr of integer numbers, ‘ar[i]’ represents the number of pages in the ‘i-th’ book. There are a ‘m’ number of students, and the task is to allocate all the books to the students. Allocate books in such a way that: Each student gets at least one book. Each book should be allocated to only one student. Book allocation should be in a contiguous manner. You have to allocate the book to ‘m’ students such that the maximum number of pages assigned to a student is minimum. If the allocation of books is not possible. return -1
Painter's Partition Problem: Given an array/list of length ‘N’, where the array/list represents the boards and each element of the given array/list represents the length of each board. Some ‘K’ numbers of painters are available to paint these boards. Consider that each unit of a board takes 1 unit of time to paint. You are supposed to return the area of the minimum time to get this job done of painting all the ‘N’ boards under the constraint that any painter will only paint the continuous sections of boards.
const splitArray = (nums, k) => {
  if (k > nums.length) return -1;
  let low = Math.max(...nums),
    high = nums.reduce((a, b) => a + b, 0);
  const isPossible = (mid) => {
    let pages = 0,
      count = 1;
    for (let num of nums) {
      pages += num;
      if (pages > mid) {
        count += 1;
        pages = num;
        if (count > k) return false;
      }
    }
    return true;
  };
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (isPossible(mid)) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return low;
};
console.log([7, 2, 5, 10, 8], 2);

-------------------------------------------------------------------------
81. Minimise Maximum Distance between Gas Stations: You are given a sorted array ‘arr’ of length ‘n’, which contains positive integer positions of ‘n’ gas stations on the X-axis. You are also given an integer ‘k’. You have to place 'k' new gas stations on the X-axis. You can place them anywhere on the non-negative side of the X-axis, even on non-integer positions. Let 'dist' be the maximum value of the distance between adjacent gas stations after adding k new gas stations. Find the minimum value of ‘dist’.
const minMaxGasStations = (arr, k) => {
  let low = 0,
    high = 0;
  for (let i = 0; i < arr.length - 1; i++) {
    high = Math.max(high, arr[i + 1] - arr[i]);
  }
  const totalCount = (mid) => {
    let count = 0;
    for (let i = 0; i < arr.length - 1; i++) {
      let diff = arr[i + 1] - arr[i];
      count += Math.ceil(diff / mid) - 1;
      if (count > k) return count;
    }
    return count;
  };
  let epsilon = 1e-6;
  while (high - low > epsilon) {
    let mid = (low + high) / 2;
    if (totalCount(mid) > k) low = mid;
    else high = mid;
  }
  return high;
};
console.log(minMaxGasStations([1, 2, 3, 4, 5], 4));

-------------------------------------------------------------------------
82. Median of Two Sorted Arrays: Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
const findMedianSortedArrays = (nums1, nums2) => {
  let m = nums1.length,
    n = nums2.length;
  if (m > n) return findMedianSortedArrays(nums2, nums1);
  let low = 0,
    high = m;
  while (low <= high) {
    let cut1 = Math.floor((low + high) / 2);
    let cut2 = Math.floor((m + n + 1) / 2) - cut1;
    let left1 = cut1 === 0 ? -Infinity : nums1[cut1 - 1];
    let left2 = cut2 === 0 ? -Infinity : nums2[cut2 - 1];
    let right1 = cut1 === m ? Infinity : nums1[cut1];
    let right2 = cut2 === n ? Infinity : nums2[cut2];
    if (left1 <= right2 && left2 <= right1) {
      if ((m + n) % 2 === 0) {
        return (Math.max(left1, left2) + Math.min(right1, right2)) / 2;
      } else return Math.max(left1, left2);
    } else if (left1 > right2) {
      high = cut1 - 1;
    } else {
      low = cut1 + 1;
    }
  }
};
console.log(findMedianSortedArrays([1, 3], [2]));

-------------------------------------------------------------------------
83. K-th Element of two sorted arrays: Given two sorted arrays a and b of size m and n respectively. Find the kth element of the final sorted array.
const findMedianSortedArrays = (nums1, nums2, k) => {
  let m = nums1.length,
    n = nums2.length;
  if (m > n) return findMedianSortedArrays(nums2, nums1, k);
  let low = Math.max(0, k - n),
    high = Math.min(k, m);
  while (low <= high) {
    let cut1 = Math.floor((low + high) / 2);
    let cut2 = k - cut1;
    let left1 = cut1 === 0 ? -Infinity : nums1[cut1 - 1];
    let left2 = cut2 === 0 ? -Infinity : nums2[cut2 - 1];
    let right1 = cut1 === m ? Infinity : nums1[cut1];
    let right2 = cut2 === n ? Infinity : nums2[cut2];
    if (left1 <= right2 && left2 <= right1) {
      return Math.max(left1, left2);
    } else if (left1 > right2) {
      high = cut1 - 1;
    } else {
      low = cut1 + 1;
    }
  }
};
console.log(findMedianSortedArrays([2, 3, 6, 7, 9], [1, 4, 8, 10], 5));

-------------------------------------------------------------------------
84. Find the row with maximum number of 1's: You have been given a non-empty grid ‘mat’ with 'n' rows and 'm' columns consisting of only 0s and 1s. All the rows are sorted in ascending order. Your task is to find the index of the row with the maximum number of ones. Note: If two rows have the same number of ones, consider the one with a smaller index. If there's no row with at least 1 zero, return -1
const rowWithMax1s = (matrix) => {
  let row = -1;
  let max = 0;
  for (let i = 0; i < matrix.length; i++) {
    let low = 0;
    let high = matrix[i].length - 1;
    while (low <= high) {
      let mid = Math.floor((low + high) / 2);
      if (matrix[i][mid] === 0) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    let onesCount = matrix[i].length - low;
    if (onesCount > max) {
      max = onesCount;
      row = i;
    }
  }
  return row;
};
console.log(
  rowWithMax1s([
    [0, 1, 1],
    [0, 0, 1],
    [1, 1, 1],
  ]),
);

-------------------------------------------------------------------------
85: Search a 2D Matrix: You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.
const searchMatrix = (matrix, target) => {
  let low = 0,
    m = matrix.length,
    n = matrix[0].length,
    high = m * n - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let i = Math.floor(mid / n),
      j = mid % n;
    if (matrix[i][j] === target) return true;
    else if (matrix[i][j] < target) low = mid + 1;
    else high = mid - 1;
  }
  return false;
};
console.log(
  [
    [1, 3, 5, 7],
    [10, 11, 16, 20],
    [23, 30, 34, 60],
  ],
  11,
);

-------------------------------------------------------------------------
86. Search a 2D Matrix II: Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
const searchMatrix = (matrix, target) => {
  let row = 0,
    col = matrix[0].length - 1;
  while (row < matrix.length && col >= 0) {
    if (matrix[row][col] === target) return true;
    else if (matrix[row][col] > target) col--;
    else row++;
  }
  return false;
};
console.log(
  [
    [1, 4, 7, 11, 15],
    [2, 5, 8, 12, 19],
    [3, 6, 9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30],
  ],
  5,
);

-------------------------------------------------------------------------
87. Find a Peak Element II: A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom. Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j]. You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell. You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.
var findPeakGrid = function (mat) {
  let rows = mat.length;
  let cols = mat[0].length;
  let low = 0,
    high = cols - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let maxIndex = 0;
    for (let i = 0; i < rows; i++) {
      if (mat[i][mid] > mat[maxIndex][mid]) {
        maxIndex = i;
      }
    }
    let left = mid === 0 ? -Infinity : mat[maxIndex][mid - 1];
    let right = mid === cols - 1 ? -Infinity : mat[maxIndex][mid + 1];
    if (mat[maxIndex][mid] > left && mat[maxIndex][mid] > right) {
      return [maxIndex, mid];
    } else if (left > mat[maxIndex][mid]) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return [-1, -1];
};
console.log(
  findPeakGrid([
    [10, 20, 15],
    [21, 30, 14],
    [7, 16, 32],
  ]),
);

-------------------------------------------------------------------------
88. 

-------------------------------------------------------------------------
STRINGS

Remove outermost parantheses: A valid parentheses string is either empty "", "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.
const removeOuterParentheses = (s) => {
  let count = 0,
    str = "";
  for (let char of s) {
    if (char === "(") {
      count += 1;
      if (count > 1) {
        str += char;
      }
    } else {
      count -= 1;
      if (count > 0) {
        str += char;
      }
    }
  }
  return str;
};
console.log(removeOuterParentheses("(()())(())"));

-------------------------------------------------------------------------
Largest Odd Number in String: You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists. A substring is a contiguous sequence of characters within a string.
const largestOddNumber = (num) => {
  let i = num.length - 1;
  while (i >= 0) {
    if ((num[i] - "0") % 2 === 1) {
      return num.substring(0, i + 1);
    }
    i--;
  }
  return "";
};
console.log(largestOddNumber("35427"));

-------------------------------------------------------------------------
Longest Common Prefix: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".
const longestCommonPrefix = (strs) => {
  if (strs.length === 0) return "";
  strs.sort();
  let start = strs[0],
    last = strs[strs.length - 1],
    commonPre = "";
  for (let i = 0; i < Math.min(start.length, last.length); i++) {
    if (start[i] === last[i]) commonPre += start[i];
    else break;
  }
  return commonPre;
};
console.log(longestCommonPrefix(["dog", "racecar", "car"]));

-------------------------------------------------------------------------
Isomorphic Strings: Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
const isIsomorphic = (s, t) => {
  if (s.length !== t.length) return false;
  let sArr = new Array(250).fill(0);
  let tArr = new Array(250).fill(0);
  for (let i = 0; i < s.length; i++) {
    let sAt = s.charCodeAt(i);
    let tAt = t.charCodeAt(i);
    if (sArr[sAt] !== tArr[tAt]) return false;
    sArr[sAt] = i + 1;
    tArr[tAt] = i + 1;
  }
  return true;
};
console.log(isIsomorphic("egg", "add"));

-------------------------------------------------------------------------